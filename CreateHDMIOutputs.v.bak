module CreateHDMIOutputs(pixclk, clk_TMDS, red, green, blue, TMDSn, TMDSn_clock);
	//define in and out
	input pixclk, clk_TMDS;
	input [7:0] red, green, blue;
	output [3:0] TMDSp, TMDSn;
	output TMDSp_clock, TMDSn_clock;
	//create output colors
	wire [9:0] TMDS_red, TMDS_green, TMDS_blue;
	TMDS_encoder encode_R(.clk(pixclk), .VD(red  ), .CD(2'b00)        , .VDE(DrawArea), .TMDS(TMDS_red));
	TMDS_encoder encode_G(.clk(pixclk), .VD(green), .CD(2'b00)        , .VDE(DrawArea), .TMDS(TMDS_green));
	TMDS_encoder encode_B(.clk(pixclk), .VD(blue ), .CD({vSync,hSync}), .VDE(DrawArea), .TMDS(TMDS_blue));

	////////////////////////////////////////////////////////////////////////
	reg [3:0] TMDS_mod10=0;  // modulus 10 counter
	reg [9:0] TMDS_shift_red=0, TMDS_shift_green=0, TMDS_shift_blue=0;
	reg TMDS_shift_load=0;
	always @(posedge clk_TMDS) TMDS_shift_load <= (TMDS_mod10==4'd9);

	always @(posedge clk_TMDS)
	begin
		TMDS_shift_red   <= TMDS_shift_load ? TMDS_red   : TMDS_shift_red  [9:1];
		TMDS_shift_green <= TMDS_shift_load ? TMDS_green : TMDS_shift_green[9:1];
		TMDS_shift_blue  <= TMDS_shift_load ? TMDS_blue  : TMDS_shift_blue [9:1];	
		TMDS_mod10 <= (TMDS_mod10==4'd9) ? 4'd0 : TMDS_mod10+4'd1;
	end

	altiobuf altobuf_red	(.datain(TMDS_shift_red[0]),	.dataout(TMDSp[2]),.dataout_b(TMDSn[2]));
	altiobuf altobuf_green(.datain(TMDS_shift_green[0]),.dataout(TMDSp[1]),.dataout_b(TMDSn[1]));
	altiobuf altobuf_blue	(.datain(TMDS_shift_blue[0]),	.dataout(TMDSp[0]),.dataout_b(TMDSn[0]));
	altiobuf altobuf_clock(.datain(pixclk), .dataout(TMDSp_clock), .dataout_b(TMDSn_clock));
endmodule
